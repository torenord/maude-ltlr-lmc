
mod PHILO is pr NAT .

  sorts Philo Status .
  op ph : Nat Status Nat -> Philo [ctor] .
  ops think hungry : -> Status [ctor] .

  sort Chopstick .
  op stk : Nat -> Chopstick [ctor] .

  sort Conf .
  subsorts Philo Chopstick < Conf .
  op none : -> Conf [ctor] .
  op _;_ : Conf Conf -> Conf [ctor comm assoc id: none] .

  sort Top .
  op <_,_> : Nat Conf -> Top .

  vars I J C N : Nat . var CF : Conf .

  op left : Nat -> Nat .
  op right : Nat Nat -> Nat .

  eq left(I) = I .
  eq right(I, N) = s(I rem N) .

  rl [wake] : ph(I, think, 0) =>   ph(I, hungry, 0) .

  crl [grab] : < N, CF ; ph(I, hungry, C) ; stk(J) > 
            => < N, CF ;  ph(I, hungry, s(C)) >
   if J == left(I) or J == right(I, N) .

  rl [stop] : < N, CF ; ph(I, hungry, 2) >
           => < N, CF ; ph(I, think, 0) ; stk(left(I)) ; stk(right(I,N)) > .

  --- initial state
  op init : Nat -> Top .
  eq init(N) = < N, makeinit(N) > .

  op makeinit : Nat -> Conf .
  eq makeinit(s N) = ph(s N, think, 0) ; stk(s N) ; makeinit(N) .
  eq makeinit(0) = none .
endm

load ltlr-checker

mod TEST-CHECK is
  pr PHILO .
  inc LTLR-MODEL-CHECKER .
  inc SPATIAL-ACTION-PATTERN .

  subsort Top < State .

  var CF : Conf .  vars I J C N : Nat .
  var CONTEXT : StateContext . var SS : StateSubstitution .

  --- support signature
  sorts Context$Conf Context$Top .
  subsorts Conf < Context$Conf .
  subsorts Top < Context$Top < StateContext .
  op _;_ : Context$Conf Conf -> Context$Conf [ditto] .
  op _;_ : Conf Context$Conf -> Context$Conf [ditto] .
  op <_,_> : Nat Context$Conf -> Context$Top .
  op [] : -> Context$Conf [ctor] .
  op [] : -> Context$Top [ctor] .

  op _\_ : Qid Nat -> StateAssignment [ctor prec 63] .

  op modelCheckParamFair : State Formula FairnessSet FairFlag ~> ModelCheckResult
      [special (id-hook LTLRFairnessCheckerSymbol
            op-hook assignmentSymbol (_\_ : Qid Nat ~> StateAssignment)
            op-hook holeSymbol       ([] : ~> Context$Conf)
            op-hook holeSymbol       ([] : ~> Context$Top)
  )] .

--- enabled
  op enabled : Action -> Prop .
  op eating : Nat -> Prop .

  eq < N, ph(I, hungry, 2) ; CF > |= eating(I) = true .

  eq  < N, CF ; ph(I, think, 0) > |= enabled({'wake}) = true .
  ceq < N, CF ; ph(I, hungry, C) ; stk(J) > |= enabled({'grab}) = true
   if J == left(I) or J == right(I,N) .

  eq  < N, CF ; ph(I, think, 0) > |= enabled({'wake : 'I \ I}) = true .
  ceq < N, CF ; ph(I, hungry, C) ; stk(J) > |= enabled({'grab : 'I \ I}) = true
   if J == left(I) or J == right(I,N) .

--- resource hierarchy check : grab lower id first? (for 4)
  op lowerFirst : -> Action .
  ceq {CONTEXT | 'grab : 'N \ N ; 'I \ I ; 'J \ J ; 'C \ 0 ; SS} |= 
	lowerFirst = true 
   if (I < N and J == I) or (I == N and J == 1) .
endm 

mod PARAM-CHECK-STRONGWEAK is
  inc TEST-CHECK .

  var CF : Conf .  vars I J C N : Nat .
  var CONTEXT : StateContext . var SS : StateSubstitution .

  --- should be AUTOMATICALLY GENERATED by FULL-Maude
  --- state props can be computed here during generation!!! (by User Option???)
  rl [test1]:
        realizedProps(< N, ph(I, think, 0) ; CF >,
	    nil)
     => realizedProps(< N, ph(I, think, 0) ; CF >,
	    enabled({'wake : 'I \ I})) .
  eq realizedProps(S:State, enabled({'wake : 'I \ I}))
   = realFair(just : enabled({'wake : 'I \ I}) => {'wake : 'I \ I}) .

  crl [test2]:
        realizedProps(
	    < N, CF ; ph(I, hungry, C) ; stk(J) >,
            nil)
     => realizedProps(
	    < N, CF ; ph(I, hungry, C) ; stk(J) >,
	    enabled({'grab : 'I \ I}))
   if J == left(I) or J == right(I,N) .
  eq realizedProps(S:State, enabled({'grab : 'I \ I}))
   = realFair(fair : enabled({'grab : 'I \ I:Nat}) => {'grab : 'I \ I:Nat}) .

  op fairFormula : Nat -> FairnessSet .
  eq fairFormula(s N) = 
   (just : enabled({'wake : 'I \ s N}) => {'wake : 'I \ s N}) ;
   (fair : enabled({'grab : 'I \ s N}) => {'grab : 'I \ s N}) ;
   fairFormula(N) .

  eq fairFormula(0) = noFairness .
endm


set verbose on .

--- safety 
red modelCheck(init(5), [] ~ deadlock) .
red modelCheck(init(5), ([] ~ lowerFirst) -> [] ~ deadlock) .

--- liveness (static)
red modelCheckFair(init(5), ([] ~ deadlock -> <> eating(1)),
    fairFormula(5)) .
red modelCheckFair(init(6), ([] ~ deadlock -> <> eating(1)),
    fairFormula(6)) .
red modelCheckFair(init(7), ([] ~ deadlock -> <> eating(1)),
    fairFormula(7)) .
red modelCheckFair(init(8), ([] ~ deadlock -> <> eating(1)),
    fairFormula(8)) .

--- liveness (param fairness)
red modelCheckParamFair(init(5), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,jfParam)) .
red modelCheckParamFair(init(6), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,jfParam)) .
red modelCheckParamFair(init(7), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,jfParam)) .
red modelCheckParamFair(init(8), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,jfParam)) .


mod PARAM-CHECK-WEAKONLY is
  inc TEST-CHECK .

  var CF : Conf .  vars I J C N : Nat .
  var CONTEXT : StateContext . var SS : StateSubstitution .

  --- should be AUTOMATICALLY GENERATED by FULL-Maude
  --- state props can be computed here during generation!!! (by User Option???)
  rl [test1]:
        realizedProps(< N, ph(I, think, 0) ; CF >,
	    nil)
     => realizedProps(< N, ph(I, think, 0) ; CF >,
	    enabled({'wake : 'I \ I})) .
  rl [test1]:
        realizedProps(S:State, 
	    enabled({'wake : 'I \ I}))
     => realFair(
	    just : enabled({'wake : 'I \ I}) => {'wake : 'I \ I}) .


  crl [test2]:
        realizedProps(
	    < N, CF ; ph(I, hungry, C) ; stk(J) >,
            nil)
     => realizedProps(
	    < N, CF ; ph(I, hungry, C) ; stk(J) >,
	    enabled({'grab : 'I \ I}))
   if J == left(I) or J == right(I,N) .
  rl [test2]:
        realizedProps(S:State, 
	    enabled({'grab : 'I \ I}))
     => realFair(
	    just : enabled({'grab : 'I \ I:Nat}) => {'grab : 'I \ I:Nat}) .

  op fairFormula : Nat -> FairnessSet .
  eq fairFormula(s N) = 
   (just : enabled({'wake : 'I \ s N}) => {'wake : 'I \ s N}) ;
   (just : enabled({'grab : 'I \ s N}) => {'grab : 'I \ s N}) ;
   fairFormula(N) .

  eq fairFormula(0) = noFairness .
endm


--- static fair testing 
red modelCheckFair(init(5), ([] ~ deadlock -> <> eating(1)),
    fairFormula(5)) .
red modelCheckFair(init(6), ([] ~ deadlock -> <> eating(1)),
    fairFormula(6)) .
red modelCheckFair(init(7), ([] ~ deadlock -> <> eating(1)),
    fairFormula(7)) .
red modelCheckFair(init(8), ([] ~ deadlock -> <> eating(1)),
    fairFormula(8)) .


--- param fair testing
red modelCheckParamFair(init(5), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,justParam)) .
red modelCheckParamFair(init(6), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,justParam)) .
red modelCheckParamFair(init(7), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,justParam)) .
red modelCheckParamFair(init(8), ([] ~ deadlock -> <> eating(1)),
    noFairness, flag(seParam,justParam)) .

